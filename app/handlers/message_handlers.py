import logging
import re
from typing import Optional, List
from telegram import Update
from telegram.ext import ContextTypes
from telegram.error import BadRequest
from app.services.llm_service import LLMService
from app.services.conversation_memory import conversation_memory
from app.services.plan_storage import plan_storage
from app.services.follow_up_questions import follow_up_service
from app.services.inline_keyboards import inline_keyboard_service
from app.services.hotel_ui_service import HotelUIService
from app.services.hotel_state_machine import hotel_state_machine
from app.services.hotel_ui_v2 import hotel_ui_v2

logger = logging.getLogger(__name__)


class MessageHandlers:
    def __init__(self):
        self.llm_service = LLMService()
        self.hotel_ui_service = HotelUIService()

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command with LLM-generated welcome"""
        user_name = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type
        
        try:
            welcome_message = await self.llm_service.generate_welcome_message(user_name, chat_type)
            await update.message.reply_text(welcome_message)
        except Exception as e:
            logger.error(f"Error in start command: {e}")
            fallback_message = (
                f"üåç Welcome {user_name}! I'm your AI travel planning assistant. "
                "Let's plan an amazing trip together! ‚úàÔ∏è"
            )
            await update.message.reply_text(fallback_message)

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = (
            "ü§ñ *TravelBot Commands & Features:*\n\n"
            "*üó∫Ô∏è Travel Planning:*\n"
            "/plan <details> - Generate structured travel plan\n"
            "/plans - List all your saved plans\n"
            "/viewplan <ID> - View detailed plan\n"
            "/deleteplan <ID> - Delete a plan\n\n"
            "*üí¨ Conversation:*\n"
            "/start - Welcome message\n"
            "/help - Show this help message\n"
            "/history - View recent conversation\n"
            "/clear - Clear conversation history\n\n"
            "*üéØ I can help with:*\n"
            "üìù Text messages - Share your travel ideas\n"
            "üîó Links - Send me travel websites or articles\n"
            "üì∏ Photos - AI-powered image analysis (menus, destinations)\n"
            "üë• Group chats - Collaborative planning\n"
            "üìã Structured plans - Detailed JSON-based itineraries\n\n"
            "*Example:* `/plan 5 days in Tokyo, budget travel, love food and culture`\n\n"
            "I use AI with conversation memory and structured planning!"
        )
        await update.message.reply_text(help_message, parse_mode="Markdown")

    async def history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show recent conversation history"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        # Get recent context
        recent_context = conversation_memory.get_recent_context(chat_id, max_messages=10)
        
        if recent_context == "No previous conversation history.":
            await update.message.reply_text(
                f"No conversation history found, {user_name}. Start chatting to build our travel planning context!"
            )
        else:
            # Get travel context summary
            travel_context = conversation_memory.get_travel_context_summary(chat_id)
            
            response = f"üìã *Recent Conversation History*\n\n{recent_context}\n\n"
            
            # Add travel context summary if available
            if travel_context["destinations_mentioned"] or travel_context["photos_shared"] > 0:
                response += "üéØ *Travel Context Summary:*\n"
                if travel_context["destinations_mentioned"]:
                    destinations = ", ".join(travel_context["destinations_mentioned"])
                    response += f"‚Ä¢ Destinations: {destinations}\n"
                if travel_context["group_size"]:
                    response += f"‚Ä¢ Travel type: {travel_context['group_size']}\n"
                if travel_context["photos_shared"] > 0:
                    response += f"‚Ä¢ Photos shared: {travel_context['photos_shared']}\n"
                if travel_context["links_shared"] > 0:
                    response += f"‚Ä¢ Links shared: {travel_context['links_shared']}\n"
            
            await update.message.reply_text(response, parse_mode="Markdown")

    async def clear_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Clear conversation history"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        conversation_memory.clear_conversation(chat_id)
        
        await update.message.reply_text(
            f"‚úÖ Conversation history cleared, {user_name}! "
            "We can start fresh with your travel planning. What would you like to explore?"
        )

    async def plan_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Generate a structured travel plan"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        # Get user requirements from command arguments
        user_requirements = " ".join(context.args) if context.args else ""
        
        if not user_requirements:
            await update.message.reply_text(
                f"üó∫Ô∏è To generate a travel plan, please provide some details!\n\n"
                f"Examples:\n"
                f"‚Ä¢ `/plan 5 days in Tokyo, budget travel, love food and culture`\n"
                f"‚Ä¢ `/plan weekend trip to Paris for couple, moderate budget`\n"
                f"‚Ä¢ `/plan family vacation to Thailand, 1 week, beaches and temples`\n\n"
                f"Or just tell me about your travel ideas and I'll create a plan based on our conversation!"
            )
            return
        
        try:
            # Send "generating" message
            generating_msg = await update.message.reply_text(
                f"üéØ Creating your travel plan, {user_name}... This will take a moment! ‚úàÔ∏è"
            )
            
            # Build context for plan generation
            plan_context = {
                "chat_id": chat_id,
                "chat_type": update.effective_chat.type,
                "user_name": user_name
            }
            
            # Generate structured travel plan
            travel_plan = await self.llm_service.generate_structured_travel_plan(
                plan_context, user_requirements
            )
            
            # Delete generating message
            await generating_msg.delete()
            
            # Format and send plan summary
            plan_summary = self._format_plan_summary(travel_plan)
            await update.message.reply_text(plan_summary, parse_mode="Markdown")
            
            # Store plan reference in conversation memory
            conversation_memory.add_assistant_message(
                chat_id=chat_id,
                content=f"Generated travel plan: {travel_plan.title} (ID: {travel_plan.id})",
                message_type="plan_generation",
                metadata={"plan_id": travel_plan.id}
            )
            
        except Exception as e:
            logger.error(f"Error generating travel plan: {e}")
            await update.message.reply_text(
                f"Sorry {user_name}, I encountered an issue generating your travel plan. "
                "Please try again or provide more specific details about your trip!"
            )

    async def plans_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """List all saved travel plans for this chat"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        # Get all plans for this chat
        plans = plan_storage.get_chat_plans(chat_id)
        
        if not plans:
            await update.message.reply_text(
                f"üìã No travel plans found, {user_name}!\n\n"
                f"Create your first plan with `/plan <your travel ideas>`\n"
                f"Example: `/plan 3 days in Rome, budget travel`"
            )
            return
        
        # Format plans list
        response = f"üìã *Your Travel Plans* ({len(plans)} total)\n\n"
        
        for i, plan in enumerate(plans, 1):
            created_date = plan.created_at.strftime("%b %d")
            response += (
                f"{i}. *{plan.title}*\n"
                f"   üìç {plan.destination} ‚Ä¢ ‚è±Ô∏è {plan.duration}\n"
                f"   üí∞ {plan.budget_level.value} ‚Ä¢ üë• {plan.travel_type.value}\n"
                f"   üìÖ Created {created_date} ‚Ä¢ üÜî `{plan.id}`\n\n"
            )
        
        response += f"Use `/viewplan <ID>` to see full details of any plan!"
        
        await update.message.reply_text(response, parse_mode="Markdown")

    async def viewplan_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """View detailed travel plan by ID"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        if not context.args:
            await update.message.reply_text(
                f"Please specify a plan ID!\n\n"
                f"Usage: `/viewplan <plan_id>`\n"
                f"Use `/plans` to see all your plan IDs."
            )
            return
        
        plan_id = context.args[0]
        travel_plan = plan_storage.get_plan(plan_id)
        
        if not travel_plan or travel_plan.chat_id != chat_id:
            await update.message.reply_text(
                f"Plan `{plan_id}` not found or doesn't belong to this chat.\n"
                f"Use `/plans` to see your available plans."
            )
            return
        
        # Format detailed plan
        detailed_plan = self._format_detailed_plan(travel_plan)
        
        # Split long messages if needed
        if len(detailed_plan) > 4000:
            parts = self._split_long_message(detailed_plan)
            for part in parts:
                await update.message.reply_text(part, parse_mode="Markdown")
        else:
            await update.message.reply_text(detailed_plan, parse_mode="Markdown")

    async def deleteplan_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Delete a travel plan"""
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        if not context.args:
            await update.message.reply_text(
                f"Please specify a plan ID to delete!\n\n"
                f"Usage: `/deleteplan <plan_id>`\n"
                f"Use `/plans` to see all your plan IDs."
            )
            return
        
        plan_id = context.args[0]
        travel_plan = plan_storage.get_plan(plan_id)
        
        if not travel_plan or travel_plan.chat_id != chat_id:
            await update.message.reply_text(
                f"Plan `{plan_id}` not found or doesn't belong to this chat."
            )
            return
        
        # Delete the plan
        success = plan_storage.delete_plan(plan_id, chat_id)
        
        if success:
            await update.message.reply_text(
                f"‚úÖ Deleted travel plan: *{travel_plan.title}*\n"
                f"Plan ID: `{plan_id}`",
                parse_mode="Markdown"
            )
        else:
            await update.message.reply_text(
                f"‚ùå Failed to delete plan `{plan_id}`. Please try again."
            )

    def _format_plan_summary(self, plan) -> str:
        """Format travel plan summary for display"""
        summary = f"üéØ *{plan.title}*\n\n"
        summary += f"üìç *Destination:* {plan.destination}\n"
        summary += f"‚è±Ô∏è *Duration:* {plan.duration}\n"
        summary += f"üë• *Travel Type:* {plan.travel_type.value.title()}\n"
        summary += f"üí∞ *Budget Level:* {plan.budget_level.value.title()}\n"
        summary += f"üÜî *Plan ID:* `{plan.id}`\n\n"
        
        summary += f"*Overview:*\n{plan.overview}\n\n"
        
        summary += f"*Budget Estimate:* {plan.total_budget_estimate}\n\n"
        
        # Add first day preview
        if plan.itinerary:
            first_day = plan.itinerary[0]
            # Handle both dict and Pydantic model formats
            if hasattr(first_day, 'theme'):
                theme = first_day.theme or 'Activities'
                activities = first_day.activities or []
            else:
                theme = first_day.get('theme', 'Activities')
                activities = first_day.get('activities', [])
            
            summary += f"*Day 1 Preview - {theme}:*\n"
            
            for i, activity in enumerate(activities[:2], 1):  # Show first 2 activities
                if hasattr(activity, 'name'):
                    activity_name = activity.name or 'Activity'
                    activity_duration = activity.duration or 'TBD'
                else:
                    activity_name = activity.get('name', 'Activity')
                    activity_duration = activity.get('duration', 'TBD')
                    
                summary += f"{i}. {activity_name} ({activity_duration})\n"
                
            if len(activities) > 2:
                summary += f"... and {len(activities) - 2} more activities\n"
            summary += "\n"
        
        summary += f"üìã Use `/viewplan {plan.id}` for complete details\n"
        summary += f"üìö Use `/plans` to see all your plans"
        
        return summary

    def _format_detailed_plan(self, plan) -> str:
        """Format detailed travel plan for display"""
        details = f"üó∫Ô∏è *{plan.title}*\n"
        details += f"_Plan ID: {plan.id} | Created by {plan.created_by}_\n\n"
        
        details += f"üìç *Destination:* {plan.destination}\n"
        details += f"‚è±Ô∏è *Duration:* {plan.duration}\n"
        details += f"üë• *Type:* {plan.travel_type.value.title()} ({plan.group_size} people)\n"
        details += f"üí∞ *Budget:* {plan.budget_level.value.title()} - {plan.total_budget_estimate}\n\n"
        
        details += f"*üìñ Overview:*\n{plan.overview}\n\n"
        
        # Accommodations
        if plan.accommodations:
            details += "*üè® Accommodations:*\n"
            for acc in plan.accommodations[:2]:  # Show first 2
                if hasattr(acc, 'name'):
                    acc_name = acc.name or 'Hotel'
                    acc_type = acc.type or 'hotel'
                    acc_location = acc.location or 'TBD'
                    acc_price = acc.price_range or 'TBD'
                else:
                    acc_name = acc.get('name', 'Hotel')
                    acc_type = acc.get('type', 'hotel')
                    acc_location = acc.get('location', 'TBD')
                    acc_price = acc.get('price_range', 'TBD')
                    
                details += f"‚Ä¢ *{acc_name}* ({acc_type})\n"
                details += f"  üìç {acc_location} | üí∞ {acc_price}\n"
            details += "\n"
        
        # Itinerary preview
        if plan.itinerary:
            details += "*üìÖ Itinerary Highlights:*\n"
            for day in plan.itinerary[:3]:  # Show first 3 days
                if hasattr(day, 'day'):
                    day_num = day.day or '?'
                    day_theme = day.theme or 'Activities'
                    activities = day.activities or []
                    daily_cost = day.estimated_cost or 'TBD'
                else:
                    day_num = day.get('day', '?')
                    day_theme = day.get('theme', 'Activities')
                    activities = day.get('activities', [])
                    daily_cost = day.get('estimated_cost', 'TBD')
                
                details += f"*Day {day_num}:* {day_theme}\n"
                
                for activity in activities[:2]:  # Show first 2 activities per day
                    if hasattr(activity, 'name'):
                        activity_name = activity.name or 'Activity'
                        activity_cost = activity.cost or 'TBD'
                    else:
                        activity_name = activity.get('name', 'Activity')
                        activity_cost = activity.get('cost', 'TBD')
                        
                    details += f"‚Ä¢ {activity_name} ({activity_cost})\n"
                    
                details += f"üí∞ Daily estimate: {daily_cost}\n\n"
        
        # Packing and tips
        if plan.packing_list:
            details += "*üéí Packing Essentials:*\n"
            for item in plan.packing_list[:5]:  # Show first 5 items
                details += f"‚Ä¢ {item}\n"
            details += "\n"
        
        if plan.local_tips:
            details += "*üí° Local Tips:*\n"
            for tip in plan.local_tips[:3]:  # Show first 3 tips
                details += f"‚Ä¢ {tip}\n"
        
        return details

    def _split_long_message(self, message: str, max_length: int = 4000) -> List[str]:
        """Split long message into multiple parts"""
        if len(message) <= max_length:
            return [message]
        
        parts = []
        current_part = ""
        
        for line in message.split('\n'):
            if len(current_part) + len(line) + 1 > max_length:
                if current_part:
                    parts.append(current_part.strip())
                current_part = line + '\n'
            else:
                current_part += line + '\n'
        
        if current_part:
            parts.append(current_part.strip())
        
        return parts

    async def handle_callback_query(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle inline keyboard button presses"""
        query = update.callback_query
        await query.answer()  # Answer the callback query
        
        try:
            # Parse callback data
            callback_data = inline_keyboard_service.parse_callback_data(query.data)
            action = callback_data.get("action", "")
            value = callback_data.get("value", "")
            
            user_name = update.effective_user.first_name or "User"
            chat_id = update.effective_chat.id
            
            # Format user's choice as natural text
            user_choice = inline_keyboard_service.format_user_answer(action, value)
            
            # Store user's selection in conversation memory
            conversation_memory.add_user_message(
                chat_id=chat_id,
                content=user_choice,
                message_type="button_selection",
                user_name=user_name,
                metadata={"action": action, "value": value}
            )
            
            # Handle different callback actions
            if action == "plan":
                # User wants to generate a plan
                await self._handle_generate_plan_callback(query, context, user_name, chat_id)
                
            elif action == "more":
                # User wants more information
                await self._handle_more_info_callback(query, context, user_name, chat_id)
                
            elif action in ["dest", "dur", "budg", "grp", "int", "date", "flight", "airline", "airport", "time"]:
                # User answered a specific question
                await self._handle_question_answer_callback(
                    query, context, action, value, user_choice, user_name, chat_id
                )
                
            elif action == "flight_choice":
                # User selected a flight option
                await self._handle_flight_choice_callback(
                    query, context, value, user_choice, user_name, chat_id
                )
            
            elif action == "quick_flight":
                # User clicked quick flight search button
                await self._handle_quick_flight_callback(
                    query, context, user_name, chat_id
                )
            
            elif action == "book_hotel":
                # User clicked book hotel button
                await self._handle_book_hotel_callback(
                    query, context, user_name, chat_id
                )
            
            elif action == "weather":
                # User clicked weather button
                await self._handle_weather_callback(
                    query, context, user_name, chat_id
                )
            
            elif action == "share_loc":
                # User clicked share location button
                await self._handle_share_location_callback(
                    query, context, user_name, chat_id
                )
            
            elif action == "hotel_ui":
                # User clicked hotel UI button
                await self._handle_hotel_ui_callback(
                    query, context, user_name, chat_id
                )
            
            elif action in ["set_city", "set_budget", "set_location", "set_tags", "set_checkin", 
                           "set_checkout", "set_party", "set_extras", "generate_recommendation",
                           "toggle_tag", "set_adults", "set_children", "set_rooms", "toggle_facility",
                           "set_view", "set_open_after", "set_brand", "confirm_children_yes",
                           "confirm_children_no", "add_child_age", "custom_city", "custom_budget",
                           "custom_location", "confirm_tags", "confirm_party", "confirm_extras",
                           "confirm_facilities", "confirm_view", "confirm_brand", "confirm_open_after",
                           "back_main", "back_extras", "change_hotels", "compare_hotels"]:
                # User clicked new hotel UI button
                await self._handle_new_hotel_ui_callback(
                    query, context, user_name, chat_id
                )
            
            # Try to remove the inline keyboard (optional) - but not for hotel_ui
            if action != "hotel_ui":
                try:
                    await query.edit_message_reply_markup(reply_markup=None)
                except BadRequest:
                    pass  # Message too old or already modified
                
        except Exception as e:
            logger.error(f"Error handling callback query: {e}")
            await query.edit_message_text("Sorry, something went wrong processing your selection.")

    async def _handle_generate_plan_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle generate plan button press"""
        
        # Update the message to show we're working
        await query.edit_message_text("üéØ *Generating your travel plan...* ‚úàÔ∏è", parse_mode="Markdown")
        
        try:
            # Build context for plan generation
            plan_context = {
                "chat_id": chat_id,
                "chat_type": query.message.chat.type,
                "user_name": user_name
            }
            
            # Generate travel plan based on conversation history
            travel_plan = await self.llm_service.generate_structured_travel_plan(
                plan_context, "Generate plan based on our conversation"
            )
            
            # Format and send plan summary
            plan_summary = self._format_plan_summary(travel_plan)
            await query.edit_message_text(plan_summary, parse_mode="Markdown")
            
            # Store plan reference in conversation memory
            conversation_memory.add_assistant_message(
                chat_id=chat_id,
                content=f"Generated travel plan: {travel_plan.title} (ID: {travel_plan.id})",
                message_type="plan_generation",
                metadata={"plan_id": travel_plan.id}
            )
            
        except Exception as e:
            logger.error(f"Error generating plan from callback: {e}")
            await query.edit_message_text(
                f"Sorry {user_name}, I encountered an issue generating your travel plan. "
                "Please try the `/plan` command with more details!"
            )

    async def _handle_more_info_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle more info button press"""
        
        try:
            # Build context for response generation
            llm_context = {
                "chat_id": chat_id,
                "chat_type": query.message.chat.type,
                "user_name": user_name
            }
            
            # Generate helpful travel information based on conversation
            response = await self.llm_service.generate_travel_response_without_followup(
                "Tell me more helpful travel information", llm_context, "text"
            )
            
            await query.edit_message_text(response, parse_mode="Markdown")
            
        except Exception as e:
            logger.error(f"Error generating more info: {e}")
            await query.edit_message_text(
                f"Here are some general travel tips, {user_name}! Feel free to ask me about destinations, "
                "budgets, activities, or anything else travel-related. I'm here to help! üåç‚úàÔ∏è"
            )

    async def _handle_question_answer_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        action: str, 
        value: str, 
        user_choice: str,
        user_name: str, 
        chat_id: int
    ):
        """Handle specific question answer button press"""
        
        try:
            # Build context for response generation
            llm_context = {
                "chat_id": chat_id,
                "chat_type": query.message.chat.type,
                "user_name": user_name
            }
            
            # Generate response acknowledging the user's choice
            acknowledgment_prompt = f"User selected: {user_choice}. Acknowledge this and provide helpful follow-up."
            
            response = await self.llm_service.generate_travel_response_without_followup(
                acknowledgment_prompt, llm_context, "text"
            )
            
            await query.edit_message_text(
                f"Great choice! {response}", 
                parse_mode="Markdown"
            )
            
            # Generate new follow-up questions based on this answer
            questions_data = await follow_up_service.generate_structured_follow_up_questions(
                user_choice, response, llm_context, max_questions=2
            )
            
            # Send new inline keyboard if we have more questions
            if questions_data:
                keyboard = inline_keyboard_service.create_follow_up_keyboard(
                    questions_data, chat_id, llm_context
                )
                
                if keyboard:
                    follow_up_text = "üí° *What else would help me plan your trip?*"
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=follow_up_text,
                        reply_markup=keyboard,
                        parse_mode="Markdown"
                    )
                    
        except Exception as e:
            logger.error(f"Error handling question answer: {e}")
            await query.edit_message_text(
                f"Thanks for your choice, {user_name}! Feel free to tell me more about your travel plans."
            )

    async def handle_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle text messages with LLM-generated responses"""
        message_text = update.message.text
        chat_type = update.effective_chat.type
        chat_id = update.effective_chat.id
        user_name = update.effective_user.first_name or "User"
        
        # Check if bot is mentioned in the message
        bot_mentioned = self._is_bot_mentioned(update, context)
        
        # Only respond if bot is mentioned (except in private chats)
        if chat_type != "private" and not bot_mentioned:
            logger.info(f"Bot not mentioned in {chat_type} chat, ignoring message")
            return
        
        # Check if message contains URLs
        urls = re.findall(
            r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+',
            message_text
        )
        
        logger.info(f"Received text from {user_name} in {chat_type}: {message_text[:50]}...")
        
        # Determine message type
        message_type = "link" if urls else "text"
        
        # Store user message in conversation memory
        conversation_memory.add_user_message(
            chat_id=chat_id,
            content=message_text,
            message_type=message_type,
            user_name=user_name,
            metadata={"urls": urls} if urls else None
        )
        
        # Build context for LLM
        llm_context = {
            "chat_type": chat_type,
            "chat_id": chat_id,
            "user_name": user_name,
            "urls": urls
        }
        
        # Initialize hotel_slots in context if not exists
        if "hotel_slots" not in llm_context:
            llm_context["hotel_slots"] = {}
        
        # Check if user is in hotel UI input mode
        if "awaiting" in context.user_data:
            awaiting = context.user_data["awaiting"]
            if awaiting in ["city", "budget"]:
                # Handle hotel UI text input
                await self._handle_hotel_ui_text_input(
                    update, context, message_text, awaiting, user_name, chat_id
                )
                return
        
        # Check if this is a hotel-related query and show new hotel UI
        if self._is_hotel_related_message(message_text):
            logger.info(f"Hotel-related message detected: {message_text[:50]}...")
            await self._show_new_hotel_ui_interface(update, context, user_name, chat_id)
            logger.info("New hotel UI interface shown, returning early")
            return
        
        try:
            # Generate response WITHOUT follow-up questions (we'll add them separately)
            response = await self.llm_service.generate_travel_response_without_followup(
                message_text, llm_context, message_type
            )
            
            # Generate structured follow-up questions for inline keyboards
            questions_data = await follow_up_service.generate_structured_follow_up_questions(
                message_text, response, llm_context, max_questions=3
            )
            
            # Create and send inline keyboard if we have questions
            if questions_data:
                keyboard = inline_keyboard_service.create_follow_up_keyboard(
                    questions_data, chat_id, llm_context
                )
                
                if keyboard:
                    # If we have a main response, send it first, then the keyboard
                    if response and response.strip():
                        await update.message.reply_text(response, parse_mode="Markdown")
                        follow_up_text = "üí° *‰Ω†Êõ¥ÂÄæÂêëÂì™‰∏™ÊñπÊ°àÔºü*"
                        await update.message.reply_text(
                            follow_up_text,
                            reply_markup=keyboard,
                            parse_mode="Markdown"
                        )
                    else:
                        # If no main response, send keyboard with a default message
                        follow_up_text = "üí° *‰Ω†Êõ¥ÂÄæÂêëÂì™‰∏™ÊñπÊ°àÔºü*"
                        await update.message.reply_text(
                            follow_up_text,
                            reply_markup=keyboard,
                            parse_mode="Markdown"
                        )
            else:
                # No follow-up questions, check if we should add custom buttons
                if response and response.strip():
                    # Check if response contains hotel recommendations - use influencer hotel response for Instagram buttons
                    # This ensures ANY response with hotel recommendations gets Instagram buttons, regardless of user's question
                    hotel_response_keywords = ["ÈÖíÂ∫ó", "hotel", "‰ΩèÂÆø", "ÂÆæÈ¶Ü", "ÊóÖÈ¶Ü", "resort", "boutique", "accommodation", "lodging", "inn", "suite", "lodge"]
                    
                    # Check if response contains hotel recommendations
                    is_hotel_response = any(keyword in response.lower() for keyword in hotel_response_keywords)
                    
                    if is_hotel_response:
                        await self._send_influencer_hotel_response(update, response, message_text, chat_id)
                    
                    # Check if this is a general travel query that could benefit from custom buttons
                    elif any(keyword in message_text.lower() for keyword in ["ÊóÖË°å", "ÊóÖÊ∏∏", "ËÆ°Âàí", "Êé®Ëçê", "Â∏ÆÂä©", "travel", "trip", "plan"]):
                        # Add custom buttons for general travel assistance
                        custom_keyboard = inline_keyboard_service.create_custom_buttons(
                            chat_id, ["quick_flight", "book_hotel", "weather"]
                        )
                        
                        if custom_keyboard:
                            await update.message.reply_text(response, parse_mode="Markdown")
                            await update.message.reply_text(
                                "üí° *ÊàëËøòÂèØ‰ª•Â∏ÆÊÇ®Ôºö*",
                                reply_markup=custom_keyboard,
                                parse_mode="Markdown"
                            )
                        else:
                            await update.message.reply_text(response, parse_mode="Markdown")
                    else:
                        await update.message.reply_text(response, parse_mode="Markdown")
                else:
                    # No response generated, send a default message with custom buttons
                    custom_keyboard = inline_keyboard_service.create_custom_buttons(
                        chat_id, ["quick_flight", "book_hotel", "weather"]
                    )
                    
                    if custom_keyboard:
                        await update.message.reply_text(
                            "ü§î Êàë‰∏çÂ§™Á°ÆÂÆöÊÇ®ÊÉ≥Ë¶Å‰ªÄ‰πàÂ∏ÆÂä©„ÄÇËÆ©Êàë‰∏∫ÊÇ®Êèê‰æõ‰∏Ä‰∫õÈÄâÈ°πÔºö",
                            reply_markup=custom_keyboard
                        )
                    else:
                        await update.message.reply_text(
                            "ü§î Êàë‰∏çÂ§™Á°ÆÂÆöÊÇ®ÊÉ≥Ë¶Å‰ªÄ‰πàÂ∏ÆÂä©„ÄÇËØ∑ÂëäËØâÊàëÊÇ®ÈúÄË¶Å‰ªÄ‰πàÔºåÊàë‰ºöÂ∞ΩÂäõÂçèÂä©ÊÇ®ÔºÅ"
                        )
            
        except Exception as e:
            logger.error(f"Error handling text message: {e}")
            fallback_response = (
                f"Thanks for sharing, {user_name}! I'm excited to help you plan an amazing trip. "
                "Could you tell me more about what you have in mind?"
            )
            await update.message.reply_text(fallback_response)

    async def handle_photo(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle photo messages with AI vision analysis"""
        user_name = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type
        chat_id = update.effective_chat.id
        
        # Get photo info
        photo = update.message.photo[-1]  # Get the highest resolution photo
        caption = update.message.caption or ""
        
        logger.info(f"Received photo from {user_name} in {chat_type}")
        
        # Store user message in conversation memory
        conversation_memory.add_user_message(
            chat_id=chat_id,
            content=caption,
            message_type="photo",
            user_name=user_name,
            metadata={"photo_file_id": photo.file_id}
        )
        
        # Build context for LLM
        llm_context = {
            "chat_type": chat_type,
            "chat_id": chat_id,
            "user_name": user_name,
            "caption": caption
        }
        
        try:
            # Send "analyzing" message first
            analyzing_msg = await update.message.reply_text(
                f"üì∏ Analyzing your photo, {user_name}... This might take a moment!"
            )
            
            # Analyze photo with OpenAI Vision
            response = await self.llm_service.analyze_photo(
                context.bot, photo, caption, llm_context
            )
            
            # Store assistant response
            conversation_memory.add_assistant_message(
                chat_id=chat_id,
                content=response,
                message_type="photo_analysis"
            )
            
            # Delete the "analyzing" message and send the result
            await analyzing_msg.delete()
            await update.message.reply_text(response, parse_mode="Markdown")
            
        except Exception as e:
            logger.error(f"Error handling photo message: {e}")
            fallback_response = (
                f"Beautiful photo, {user_name}! üì∏ This looks like an amazing destination. "
                "What kind of activities are you interested in there?"
            )
            await update.message.reply_text(fallback_response)

    async def handle_image_document(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle image files sent as documents with AI vision analysis"""
        user_name = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type
        chat_id = update.effective_chat.id
        document = update.message.document
        
        logger.info(f"Received image document from {user_name} in {chat_type}: {document.file_name}")
        
        # Check if it's an image file
        if not document.mime_type or not document.mime_type.startswith('image/'):
            await update.message.reply_text(
                f"Thanks for the file, {user_name}! However, I can only analyze image files. "
                "Please send photos or image documents for visual analysis."
            )
            return
        
        # Store user message in conversation memory
        conversation_memory.add_user_message(
            chat_id=chat_id,
            content=f"Document: {document.file_name}",
            message_type="document",
            user_name=user_name,
            metadata={
                "file_id": document.file_id,
                "filename": document.file_name,
                "mime_type": document.mime_type
            }
        )
        
        # Build context for LLM  
        llm_context = {
            "chat_type": chat_type,
            "chat_id": chat_id,
            "user_name": user_name,
            "filename": document.file_name
        }
        
        try:
            # Send "analyzing" message first
            analyzing_msg = await update.message.reply_text(
                f"üñºÔ∏è Analyzing your image document, {user_name}... This might take a moment!"
            )
            
            # Create a pseudo photo object for document analysis
            # We'll download the document directly
            file = await context.bot.get_file(document.file_id)
            file_bytes = await file.download_as_bytearray()
            
            # Use the same photo analysis but with document download
            response = await self.llm_service.analyze_document_image(
                file_bytes, document.file_name, llm_context
            )
            
            # Store assistant response
            conversation_memory.add_assistant_message(
                chat_id=chat_id,
                content=response,
                message_type="document_analysis"
            )
            
            # Delete the "analyzing" message and send the result
            await analyzing_msg.delete()
            await update.message.reply_text(response, parse_mode="Markdown")
            
        except Exception as e:
            logger.error(f"Error handling image document: {e}")
            fallback_response = (
                f"Thanks for the image, {user_name}! üñºÔ∏è "
                "This will help me understand your travel preferences better!"
            )
            await update.message.reply_text(fallback_response)

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle errors"""
        logger.error(f"Update {update} caused error {context.error}")
        
        # Try to send a user-friendly error message
        if update and update.effective_message:
            try:
                await update.effective_message.reply_text(
                    "Sorry, I encountered an issue processing your request. "
                    "Please try again or contact support if the problem persists."
                )
            except Exception as e:
                logger.error(f"Failed to send error message: {e}")

    async def _handle_flight_choice_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        value: str, 
        user_choice: str,
        user_name: str, 
        chat_id: int
    ):
        """Handle flight option selection callback"""
        
        try:
            # Build context for response generation
            llm_context = {
                "chat_id": chat_id,
                "chat_type": query.message.chat.type,
                "user_name": user_name
            }
            
            # Send notification in group chats
            if query.message.chat.type in ["group", "supergroup"]:
                notification_text = f"üë§ Áî®Êà∑ {user_name} ÈÄâÊã©‰∫Ü {value}"
                await query.message.reply_text(notification_text)
            
            if value == "ÈÉΩ‰∏çÊª°ÊÑè":
                # User is not satisfied with any option
                response = await self.llm_service.generate_travel_response_without_followup(
                    "Áî®Êà∑ÈÄâÊã©‰∫Ü'ÈÉΩ‰∏çÊª°ÊÑè'ÔºåËØ∑Êèê‰æõÂÖ∂‰ªñËà™Áè≠ÈÄâÊã©ÊàñÂª∫ËÆÆ", llm_context, "text"
                )
                
                await query.edit_message_text(
                    f"ÊàëÁêÜËß£ÊÇ®ÂØπÂΩìÂâçÊñπÊ°à‰∏çÊª°ÊÑèÔºå{user_name}ÔºÅ{response}", 
                    parse_mode="Markdown"
                )
            else:
                # User selected a specific flight option
                response = await self.llm_service.generate_travel_response_without_followup(
                    f"Áî®Êà∑ÈÄâÊã©‰∫Ü{value}ÔºåËØ∑Êèê‰æõËØ•ÊñπÊ°àÁöÑËØ¶ÁªÜ‰ø°ÊÅØ„ÄÅÈ¢ÑËÆ¢Âª∫ËÆÆÂíåÂêéÁª≠Ê≠•È™§", llm_context, "text"
                )
                
                await query.edit_message_text(
                    f"ÂæàÂ•ΩÁöÑÈÄâÊã©ÔºÅÊÇ®ÈÄâÊã©‰∫Ü{value}„ÄÇ{response}", 
                    parse_mode="Markdown"
                )
            
            # Generate new follow-up questions based on this choice
            questions_data = await follow_up_service.generate_structured_follow_up_questions(
                user_choice, f"User selected {value}", llm_context, max_questions=2
            )
            
            # Send new inline keyboard if we have more questions
            if questions_data:
                keyboard = inline_keyboard_service.create_follow_up_keyboard(
                    questions_data, chat_id, llm_context
                )
                
                if keyboard:
                    follow_up_text = "üí° *ËøòÊúâ‰ªÄ‰πàÂèØ‰ª•Â∏ÆÂä©ÊÇ®ÂÆåÂñÑÊóÖË°åËÆ°ÂàíÔºü*"
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=follow_up_text,
                        reply_markup=keyboard,
                        parse_mode="Markdown"
                    )
                    
        except Exception as e:
            logger.error(f"Error handling flight choice: {e}")
            await query.edit_message_text(
                f"Ë∞¢Ë∞¢ÊÇ®ÁöÑÈÄâÊã©Ôºå{user_name}ÔºÅÂ¶ÇÊûúÊÇ®ÈúÄË¶ÅÊõ¥Â§öÂ∏ÆÂä©ÔºåËØ∑ÈöèÊó∂ÂëäËØâÊàë„ÄÇ"
            )

    async def _handle_quick_flight_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle quick flight search button"""
        try:
            await query.edit_message_text(
                f"‚úàÔ∏è Â•ΩÁöÑÔºå{user_name}ÔºÅÊàëÊù•Â∏ÆÊÇ®Âø´ÈÄüÊü•ËØ¢Ëà™Áè≠„ÄÇ\n\n"
                "ËØ∑ÂëäËØâÊàëÔºö\n"
                "1. Âá∫ÂèëÂüéÂ∏ÇÂíåÁõÆÁöÑÂú∞\n"
                "2. Âá∫ÂèëÊó•Êúü\n"
                "3. ÊòØÂê¶ÂæÄËøîÔºàÂ¶ÇÊûúÊòØÔºåËØ∑Êèê‰æõËøîÁ®ãÊó•ÊúüÔºâ\n\n"
                "‰æãÂ¶ÇÔºö'‰∏äÊµ∑Âà∞Á∫ΩÁ∫¶Ôºå10Êúà1Âè∑Âá∫ÂèëÔºå10Êúà5Âè∑ËøîÂõû'"
            )
        except Exception as e:
            logger.error(f"Error handling quick flight callback: {e}")

    async def _handle_book_hotel_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle book hotel button"""
        try:
            await query.edit_message_text(
                f"üè® Â•ΩÁöÑÔºå{user_name}ÔºÅÊàëÊù•Â∏ÆÊÇ®È¢ÑËÆ¢ÈÖíÂ∫ó„ÄÇ\n\n"
                "ËØ∑ÂëäËØâÊàëÔºö\n"
                "1. ÁõÆÁöÑÂú∞ÂüéÂ∏Ç\n"
                "2. ÂÖ•‰ΩèÂíåÈÄÄÊàøÊó•Êúü\n"
                "3. ÊàøÈó¥Êï∞ÈáèÂíåÂÆ¢‰∫∫Êï∞Èáè\n"
                "4. È¢ÑÁÆóËåÉÂõ¥ÔºàÂèØÈÄâÔºâ\n\n"
                "‰æãÂ¶ÇÔºö'Á∫ΩÁ∫¶Ôºå10Êúà1Âè∑Âà∞10Êúà5Âè∑Ôºå2‰∏™ÊàøÈó¥Ôºå4‰∏™ÂÆ¢‰∫∫'"
            )
        except Exception as e:
            logger.error(f"Error handling book hotel callback: {e}")

    async def _handle_weather_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle weather button"""
        try:
            await query.edit_message_text(
                f"üå§Ô∏è Â•ΩÁöÑÔºå{user_name}ÔºÅÊàëÊù•Â∏ÆÊÇ®Êü•ÁúãÂ§©Ê∞î‰ø°ÊÅØ„ÄÇ\n\n"
                "ËØ∑ÂëäËØâÊàëÔºö\n"
                "1. ÊÇ®ÊÉ≥Êü•ËØ¢Âì™‰∏™ÂüéÂ∏ÇÁöÑÂ§©Ê∞îÔºü\n"
                "2. ÈúÄË¶ÅÊü•ÁúãÂì™Âá†Â§©ÁöÑÂ§©Ê∞îÔºüÔºàÂèØÈÄâÔºâ\n\n"
                "‰æãÂ¶ÇÔºö'Á∫ΩÁ∫¶ÁöÑÂ§©Ê∞î' Êàñ '‰∏ú‰∫¨10Êúà1Âè∑Âà∞10Êúà5Âè∑ÁöÑÂ§©Ê∞î'"
            )
        except Exception as e:
            logger.error(f"Error handling weather callback: {e}")

    async def _handle_share_location_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle share location button"""
        try:
            await query.edit_message_text(
                f"üìç Â•ΩÁöÑÔºå{user_name}ÔºÅ\n\n"
                "ËØ∑ÂàÜ‰∫´ÊÇ®ÁöÑ‰ΩçÁΩÆÔºåËøôÊ†∑ÊàëÂèØ‰ª•Ôºö\n"
                "‚Ä¢ ‰∏∫ÊÇ®Êé®ËçêÈôÑËøëÁöÑÊôØÁÇπÂíåÈ§êÂéÖ\n"
                "‚Ä¢ Êèê‰æõÂΩìÂú∞ÁöÑ‰∫§ÈÄö‰ø°ÊÅØ\n"
                "‚Ä¢ Êü•ÁúãÊÇ®ÂΩìÂâç‰ΩçÁΩÆÁöÑÂ§©Ê∞î\n"
                "‚Ä¢ ËßÑÂàí‰ªéÊÇ®ÂΩìÂâç‰ΩçÁΩÆÂá∫ÂèëÁöÑË∑ØÁ∫ø\n\n"
                "ËØ∑ÁÇπÂáªTelegramÁöÑ'ÂàÜ‰∫´‰ΩçÁΩÆ'ÊåâÈíÆÂèëÈÄÅÊÇ®ÁöÑ‰ΩçÁΩÆ„ÄÇ"
            )
        except Exception as e:
            logger.error(f"Error handling share location callback: {e}")

    async def _handle_hotel_ui_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Handle hotel UI callback queries"""
        try:
            callback_data = query.data
            
            # Initialize hotel slots if not exists
            if "hotel_slots" not in context.user_data:
                context.user_data["hotel_slots"] = {
                    "city": None,
                    "check_in": None,
                    "nights": None,
                    "check_out": None,
                    "budget_range_local": None,
                    "party": {"adults": 2, "children": 0, "rooms": 1},
                }
            
            slots = context.user_data["hotel_slots"]
            
            if callback_data == "hotel_ui:back_main":
                # Return to main menu
                await query.edit_message_text(
                    self.hotel_ui_service.get_initial_message(slots),
                    reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
                )
                return
            
            elif callback_data == "hotel_ui:ask_city":
                # Ask for city input
                await query.edit_message_text(
                    self.hotel_ui_service.get_city_input_message()
                )
                context.user_data["awaiting"] = "city"
                return
            
            elif callback_data == "hotel_ui:ask_checkin":
                # Show date selection
                await query.edit_message_text(
                    "üìÖ **ËØ∑ÈÄâÊã©ÂÖ•‰ΩèÊó•Êúü**\n\nÈÄâÊã©Êú™Êù•14Â§©ÂÜÖÁöÑÊó•ÊúüÔºö",
                    reply_markup=self.hotel_ui_service.get_quick_dates_keyboard()
                )
                return
            
            elif callback_data == "hotel_ui:ask_nights":
                # Show nights selection
                await query.edit_message_text(
                    "üõè **ËØ∑ÈÄâÊã©‰ΩèÂÆøÊôöÊï∞**\n\nÈÄâÊã©ÊÇ®ËÆ°Âàí‰ΩèÂá†ÊôöÔºö",
                    reply_markup=self.hotel_ui_service.get_nights_keyboard()
                )
                return
            
            elif callback_data == "hotel_ui:ask_budget":
                # Show budget selection
                await query.edit_message_text(
                    "üí∞ **ËØ∑ÈÄâÊã©ÊØèÊôöÈ¢ÑÁÆó**\n\nÈÄâÊã©ÊÇ®ÁöÑÈ¢ÑÁÆóËåÉÂõ¥Ôºö",
                    reply_markup=self.hotel_ui_service.get_budget_keyboard()
                )
                return
            
            elif callback_data == "hotel_ui:ask_party":
                # Show party selection
                await query.edit_message_text(
                    self.hotel_ui_service.get_summary_text(slots) + 
                    "\n\nüë™ **Ë∞ÉÊï¥ÂêåË°å‰∫∫Êï∞ÂíåÊàøÈó¥Êï∞**\n\n‰ΩøÁî®‰∏ãÊñπÊåâÈíÆË∞ÉÊï¥Ôºö",
                    reply_markup=self.hotel_ui_service.get_party_keyboard()
                )
                return
            
            elif callback_data == "hotel_ui:custom_budget":
                # Ask for custom budget
                await query.edit_message_text(
                    self.hotel_ui_service.get_budget_input_message()
                )
                context.user_data["awaiting"] = "budget"
                return
            
            elif callback_data == "hotel_ui:done":
                # Complete hotel search
                await query.edit_message_text(
                    self.hotel_ui_service.get_completion_message(slots)
                )
                
                # Generate hotel recommendations using the collected slots
                await self._generate_hotel_recommendations_from_slots(
                    query, context, slots, user_name, chat_id
                )
                return
            
            # Handle slot updates (only if not handled by specific cases above)
            try:
                if self.hotel_ui_service.update_slots_from_callback(slots, callback_data):
                    # Update successful, show updated summary
                    await query.edit_message_text(
                        self.hotel_ui_service.get_summary_text(slots),
                        reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
                    )
                    return
                else:
                    # Update failed, show error message
                    await query.edit_message_text(
                        "‚ùå ËÆæÁΩÆÂ§±Ë¥•ÔºåËØ∑ÈáçËØï„ÄÇ",
                        reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
                    )
                    return
            except Exception as e:
                logger.error(f"Error updating slots from callback: {e}")
                await query.edit_message_text(
                    "‚ùå Â§ÑÁêÜÊÇ®ÁöÑÈÄâÊã©Êó∂Âá∫Áé∞ÈîôËØØÔºåËØ∑ÈáçËØï„ÄÇ",
                    reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
                )
                return
            
        except Exception as e:
            logger.error(f"Error handling hotel UI callback: {e}")
            await query.edit_message_text("Êä±Ê≠âÔºåÂ§ÑÁêÜÊÇ®ÁöÑÈÄâÊã©Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇ")

    async def _generate_hotel_recommendations_from_slots(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        slots: dict, 
        user_name: str, 
        chat_id: int
    ):
        """Generate hotel recommendations from collected slots"""
        try:
            logger.info(f"Generating hotel recommendations from slots: {slots}")
            
            # Convert slots to hotel agent format - include all required fields
            from app.services.hotel_agent import hotel_agent
            default_slots = hotel_agent._initialize_slots()
            
            hotel_slots = {
                "city": slots.get("city"),
                "check_in": slots.get("check_in"),
                "check_out": slots.get("check_out"),
                "party": slots.get("party", {"adults": 2, "children": 0, "rooms": 1}),
                "budget_range_local": slots.get("budget_range_local"),
                "city_type": "A",  # Default to A tier
                "star_level": default_slots["star_level"],
                "preferred_area": default_slots["preferred_area"],
                "preferred_brands": default_slots["preferred_brands"],
                "special_needs": default_slots["special_needs"],
                "view": default_slots["view"],
                "breakfast_needed": default_slots["breakfast_needed"],
                "style": default_slots["style"]
            }
            
            logger.info(f"Converted hotel_slots: {hotel_slots}")
            
            # Use hotel agent to generate recommendations
            hotel_agent.slots = hotel_slots
            logger.info(f"Set hotel_agent.slots: {hotel_agent.slots}")
            
            # Generate hotel recommendations
            # The method uses hotel_agent.slots internally, so we just need to pass any context
            logger.info("Calling _generate_hotel_recommendations...")
            recommendations = await self.llm_service._generate_hotel_recommendations({})
            logger.info(f"Generated recommendations: {recommendations[:100] if recommendations else 'None'}...")
            
            if recommendations:
                # Send recommendations with Instagram buttons
                # Create a mock update object for the callback query
                from telegram import Update
                mock_update = Update(update_id=0, callback_query=query)
                await self._send_influencer_hotel_response(
                    mock_update, recommendations, slots.get("city", ""), chat_id
                )
            else:
                await query.edit_message_text(
                    "Êä±Ê≠âÔºåÊ≤°ÊúâÊâæÂà∞ÂêàÈÄÇÁöÑÈÖíÂ∫óÊé®Ëçê„ÄÇËØ∑Â∞ùËØïË∞ÉÊï¥ÊÇ®ÁöÑÊêúÁ¥¢Êù°‰ª∂„ÄÇ"
                )
                
        except Exception as e:
            logger.error(f"Error generating hotel recommendations: {e}")
            await query.edit_message_text(
                "Êä±Ê≠âÔºåÁîüÊàêÈÖíÂ∫óÊé®ËçêÊó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇËØ∑Á®çÂêéÈáçËØï„ÄÇ"
            )

    async def _handle_hotel_ui_text_input(
        self, 
        update: Update, 
        context: ContextTypes.DEFAULT_TYPE, 
        message_text: str, 
        awaiting: str, 
        user_name: str, 
        chat_id: int
    ):
        """Handle hotel UI text input (city, budget)"""
        try:
            # Initialize hotel slots if not exists
            if "hotel_slots" not in context.user_data:
                context.user_data["hotel_slots"] = {
                    "city": None,
                    "check_in": None,
                    "nights": None,
                    "check_out": None,
                    "budget_range_local": None,
                    "party": {"adults": 2, "children": 0, "rooms": 1},
                }
            
            slots = context.user_data["hotel_slots"]
            
            # Update slots based on input
            if self.hotel_ui_service.update_slots_from_text(slots, message_text, awaiting):
                # Clear awaiting state
                context.user_data["awaiting"] = None
                
                # Send confirmation and show updated menu
                await update.message.reply_text(
                    f"‚úÖ Â∑≤ËÆæÁΩÆ{'ÁõÆÁöÑÂú∞' if awaiting == 'city' else 'È¢ÑÁÆó'}ÔºÅ\n\n" +
                    self.hotel_ui_service.get_summary_text(slots),
                    reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
                )
            else:
                await update.message.reply_text(
                    "‚ùå ËæìÂÖ•Ê†ºÂºè‰∏çÊ≠£Á°ÆÔºåËØ∑ÈáçÊñ∞ËæìÂÖ•Ôºö\n\n" +
                    (self.hotel_ui_service.get_city_input_message() if awaiting == "city" 
                     else self.hotel_ui_service.get_budget_input_message())
                )
                
        except Exception as e:
            logger.error(f"Error handling hotel UI text input: {e}")
            await update.message.reply_text("Êä±Ê≠âÔºåÂ§ÑÁêÜÊÇ®ÁöÑËæìÂÖ•Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇ")

    def _is_hotel_related_message(self, message: str) -> bool:
        """Check if message is hotel-related"""
        hotel_keywords = [
            "ÈÖíÂ∫ó", "hotel", "‰ΩèÂÆø", "ÂÆæÈ¶Ü", "ÊóÖÈ¶Ü", "resort", "boutique", 
            "accommodation", "lodging", "inn", "suite", "lodge", "È¢ÑËÆ¢ÈÖíÂ∫ó",
            "Êé®ËçêÈÖíÂ∫ó", "ÈÖíÂ∫óÊé®Ëçê", "ËÆ¢ÈÖíÂ∫ó", "ÊâæÈÖíÂ∫ó", "ÈÖíÂ∫óÈÄâÊã©"
        ]
        message_lower = message.lower()
        return any(keyword in message_lower for keyword in hotel_keywords)

    async def _show_hotel_ui_interface(
        self, 
        update: Update, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Show hotel UI interface"""
        try:
            # Initialize hotel slots if not exists
            if "hotel_slots" not in context.user_data:
                context.user_data["hotel_slots"] = {
                    "city": None,
                    "check_in": None,
                    "nights": None,
                    "check_out": None,
                    "budget_range_local": None,
                    "party": {"adults": 2, "children": 0, "rooms": 1},
                }
            
            slots = context.user_data["hotel_slots"]
            
            # Try to extract city from message
            city = self._extract_city_from_message(update.message.text)
            if city:
                slots["city"] = city
            
            await update.message.reply_text(
                self.hotel_ui_service.get_initial_message(slots),
                reply_markup=self.hotel_ui_service.get_main_menu_keyboard()
            )
            
        except Exception as e:
            logger.error(f"Error showing hotel UI interface: {e}")
            await update.message.reply_text("Êä±Ê≠âÔºåÊòæÁ§∫ÈÖíÂ∫óÊé®ËçêÁïåÈù¢Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇ")
    
    async def _show_new_hotel_ui_interface(
        self, 
        update: Update, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """ÊòæÁ§∫Êñ∞ÁöÑÈÖíÂ∫óUIÁïåÈù¢"""
        try:
            # ‰∏∫ÊØè‰∏™Áî®Êà∑ÂàõÂª∫Áã¨Á´ãÁöÑÁä∂ÊÄÅÊú∫ÂÆû‰æã
            if "hotel_state_machine" not in context.user_data:
                from app.services.hotel_state_machine import HotelStateMachine
                context.user_data["hotel_state_machine"] = HotelStateMachine()
            
            state_machine = context.user_data["hotel_state_machine"]
            
            # ‰ΩøÁî®Êñ∞ÁöÑÁä∂ÊÄÅÊú∫Â§ÑÁêÜÊ∂àÊÅØ
            state, message, keyboard_data = state_machine.process_message(
                update.message.text, None
            )
            
            # Ëé∑ÂèñÈîÆÁõò
            keyboard = hotel_ui_v2.get_keyboard(keyboard_data["type"])
            
            await update.message.reply_text(
                message,
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"Error showing new hotel UI interface: {e}")
            await update.message.reply_text("Êä±Ê≠âÔºåÊòæÁ§∫ÈÖíÂ∫óÊé®ËçêÁïåÈù¢Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇ")
    
    async def _handle_new_hotel_ui_callback(
        self, 
        query, 
        context: ContextTypes.DEFAULT_TYPE, 
        user_name: str, 
        chat_id: int
    ):
        """Â§ÑÁêÜÊñ∞ÁöÑÈÖíÂ∫óUIÂõûË∞É"""
        try:
            callback_data = query.data
            logger.info(f"Handling new hotel UI callback: {callback_data}")
            
            # ‰∏∫ÊØè‰∏™Áî®Êà∑ÂàõÂª∫Áã¨Á´ãÁöÑÁä∂ÊÄÅÊú∫ÂÆû‰æã
            if "hotel_state_machine" not in context.user_data:
                from app.services.hotel_state_machine import HotelStateMachine
                context.user_data["hotel_state_machine"] = HotelStateMachine()
            
            state_machine = context.user_data["hotel_state_machine"]
            
            # ‰ΩøÁî®Êñ∞ÁöÑÁä∂ÊÄÅÊú∫Â§ÑÁêÜÂõûË∞É
            logger.info(f"Processing callback: {callback_data}")
            state, message, keyboard_data = state_machine.process_message(
                None, callback_data
            )
            
            logger.info(f"State machine returned: state={state}")
            logger.info(f"Message length: {len(message)}, content: {message}")
            logger.info(f"Keyboard data: {keyboard_data}")
            
            # Ëé∑ÂèñÈîÆÁõò
            keyboard = hotel_ui_v2.get_keyboard(keyboard_data["type"])
            logger.info(f"Generated keyboard type: {keyboard_data['type']}")
            logger.info(f"Keyboard object: {keyboard}")
            logger.info(f"Keyboard inline_keyboard: {keyboard.inline_keyboard if keyboard else 'None'}")
            
            # Ê£ÄÊü•ÈîÆÁõòÊòØÂê¶‰∏∫Á©∫
            if keyboard is None:
                logger.error(f"Keyboard is None for type: {keyboard_data['type']}")
                keyboard = hotel_ui_v2.get_keyboard("main_menu")  # ‰ΩøÁî®‰∏ªËèúÂçï‰Ωú‰∏∫Â§áÁî®
                logger.info(f"Using fallback keyboard: {keyboard}")
            
            # Â∞ùËØïÁºñËæëÊ∂àÊÅØÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôÂèëÈÄÅÊñ∞Ê∂àÊÅØ
            logger.info("Attempting to edit message...")
            try:
                await query.edit_message_text(
                    message,
                    reply_markup=keyboard,
                    parse_mode='Markdown'
                )
                logger.info("‚úÖ Successfully edited message with keyboard")
            except Exception as edit_error:
                logger.warning(f"‚ùå Edit message failed: {edit_error}")
                logger.warning(f"Error type: {type(edit_error)}")
                logger.warning(f"Error details: {str(edit_error)}")
                # ÁºñËæëÂ§±Ë¥•ÔºåÂèëÈÄÅÊñ∞Ê∂àÊÅØ
                logger.info("Attempting to send new message...")
                try:
                    await query.message.reply_text(
                        message,
                        reply_markup=keyboard,
                        parse_mode='Markdown'
                    )
                    logger.info("‚úÖ Successfully sent new message with keyboard")
                except Exception as reply_error:
                    logger.error(f"‚ùå Reply message also failed: {reply_error}")
                    logger.error(f"Reply error type: {type(reply_error)}")
                    # ÊúÄÂêéÁöÑÂ§áÁî®ÊñπÊ°àÔºöÂèëÈÄÅÁÆÄÂçïÊ∂àÊÅØ
                    try:
                        await query.message.reply_text(
                            "Êä±Ê≠âÔºåÊòæÁ§∫È¢ÑÁÆóÈÄâÊã©Êó∂Âá∫Áé∞‰∫ÜÈóÆÈ¢ò„ÄÇËØ∑ÈáçËØï„ÄÇ",
                            reply_markup=keyboard
                        )
                    except Exception as final_error:
                        logger.error(f"Final fallback also failed: {final_error}")
                        # ÊúÄÂêéÁöÑÊúÄÂêéÔºöÂè™ÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ
                        await query.message.reply_text(
                            "Êä±Ê≠âÔºåÊòæÁ§∫È¢ÑÁÆóÈÄâÊã©Êó∂Âá∫Áé∞‰∫ÜÈóÆÈ¢ò„ÄÇËØ∑ÈáçËØï„ÄÇ"
                        )
            
        except Exception as e:
            logger.error(f"Error handling new hotel UI callback: {e}")
            # ÂèëÈÄÅÂ∏¶ÈîÆÁõòÁöÑÈîôËØØÊ∂àÊÅØ
            try:
                error_keyboard = hotel_ui_v2.get_keyboard("main_menu")
                await query.edit_message_text(
                    "Êä±Ê≠âÔºåÂ§ÑÁêÜÊÇ®ÁöÑÈÄâÊã©Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇËØ∑ÈáçËØï„ÄÇ",
                    reply_markup=error_keyboard
                )
            except:
                await query.message.reply_text("Êä±Ê≠âÔºåÂ§ÑÁêÜÊÇ®ÁöÑÈÄâÊã©Êó∂Âá∫Áé∞‰∫ÜÈîôËØØ„ÄÇËØ∑ÈáçËØï„ÄÇ")

    def _extract_city_from_message(self, message: str) -> str:
        """Extract city name from message"""
        # Simple city extraction - can be enhanced
        cities = ["‰∏ú‰∫¨", "Tokyo", "‰∏äÊµ∑", "Shanghai", "Âåó‰∫¨", "Beijing", "Â§ßÈò™", "Osaka", 
                 "‰∫¨ÈÉΩ", "Kyoto", "ÁÆ±Ê†π", "Hakone", "Á∫ΩÁ∫¶", "New York", "Â∑¥Èªé", "Paris",
                 "‰º¶Êï¶", "London", "Êñ∞Âä†Âù°", "Singapore", "È¶ôÊ∏Ø", "Hong Kong", "Âè∞Âåó", "Taipei"]
        
        for city in cities:
            if city in message:
                return city
        return None

    async def _send_hotel_response_with_media(
        self, 
        update: Update, 
        response: str, 
        message_text: str, 
        chat_id: int
    ):
        """Send hotel response with hotel image and TripAdvisor ratings"""
        try:
            # Extract destination from message
            destination = self._extract_destination_from_message(message_text)
            
            if destination:
                # Get real-time hotel info with TripAdvisor ratings
                realtime_hotel_info = await self.llm_service.get_realtime_hotel_info(destination)
                
                # Send text response first
                await update.message.reply_text(response, parse_mode="Markdown")
                
                # Send real-time hotel info with TripAdvisor ratings if available
                if realtime_hotel_info:
                    await update.message.reply_text(realtime_hotel_info, parse_mode="Markdown")
                
                # Get hotel media URLs for the destination
                hotel_media_urls = self.llm_service.get_hotel_media_urls_for_destination(destination)
                
                # Send hotel image
                await self.llm_service.send_media_with_text(
                    bot=update.get_bot(),
                    chat_id=chat_id,
                    text="",  # No additional text
                    media_type="photo",
                    media_url=hotel_media_urls.get("photo"),
                    caption=f"üè® *{destination}ÁöÑÁ≤æÈÄâÈÖíÂ∫ó* - ‰∏∫ÊÇ®Êé®Ëçê‰ºòË¥®‰ΩèÂÆøÔºÅ",
                    parse_mode="Markdown"
                )
            else:
                # Fallback to regular text response
                await update.message.reply_text(response, parse_mode="Markdown")
                
        except Exception as e:
            logger.error(f"Error sending hotel response with media: {e}")
            # Fallback to regular text response
            await update.message.reply_text(response, parse_mode="Markdown")

    def _extract_destination_from_message(self, message_text: str) -> str:
        """Extract destination from message text"""
        message_lower = message_text.lower()
        
        # Map of destination keywords to normalized names
        destination_map = {
            "‰∏ú‰∫¨": "tokyo",
            "tokyo": "tokyo",
            "Á∫ΩÁ∫¶": "new_york", 
            "new york": "new_york",
            "Â∑¥Èªé": "paris",
            "paris": "paris",
            "‰º¶Êï¶": "london",
            "london": "london",
            "Â§ßÈò™": "osaka",
            "osaka": "osaka",
            "‰∫¨ÈÉΩ": "kyoto",
            "kyoto": "kyoto",
            "ÂêçÂè§Â±ã": "nagoya",
            "nagoya": "nagoya",
            "È¶ñÂ∞î": "seoul",
            "seoul": "seoul",
            "Êñ∞Âä†Âù°": "singapore",
            "singapore": "singapore",
            "ÂêâÈöÜÂù°": "kuala_lumpur",
            "kuala lumpur": "kuala_lumpur",
            "ÊõºË∞∑": "bangkok",
            "bangkok": "bangkok",
            "Âè∞Âåó": "taipei",
            "taipei": "taipei",
            "È¶ôÊ∏Ø": "hong_kong",
            "hong kong": "hong_kong",
            "‰∏äÊµ∑": "shanghai",
            "shanghai": "shanghai",
            "Âåó‰∫¨": "beijing",
            "beijing": "beijing",
            "Ê∑±Âú≥": "shenzhen",
            "shenzhen": "shenzhen",
            "ÂπøÂ∑û": "guangzhou",
            "guangzhou": "guangzhou",
            "ÊàêÈÉΩ": "chengdu",
            "chengdu": "chengdu",
            "Êù≠Â∑û": "hangzhou",
            "hangzhou": "hangzhou",
            "Âçó‰∫¨": "nanjing",
            "nanjing": "nanjing",
            "Ê≠¶Ê±â": "wuhan",
            "wuhan": "wuhan",
            "Ë•øÂÆâ": "xian",
            "xian": "xian",
            "ÈáçÂ∫Ü": "chongqing",
            "chongqing": "chongqing",
            "Â§©Ê¥•": "tianjin",
            "tianjin": "tianjin",
            "ÈùíÂ≤õ": "qingdao",
            "qingdao": "qingdao",
            "Â§ßËøû": "dalian",
            "dalian": "dalian",
            "Âé¶Èó®": "xiamen",
            "xiamen": "xiamen",
            "ËãèÂ∑û": "suzhou",
            "suzhou": "suzhou",
            "Êó†Èî°": "wuxi",
            "wuxi": "wuxi",
            "ÂÆÅÊ≥¢": "ningbo",
            "ningbo": "ningbo",
            "Ê∏©Â∑û": "wenzhou",
            "wenzhou": "wenzhou",
            "Á¶èÂ∑û": "fuzhou",
            "fuzhou": "fuzhou",
            "ÊµéÂçó": "jinan",
            "jinan": "jinan",
            "Áü≥ÂÆ∂Â∫Ñ": "shijiazhuang",
            "shijiazhuang": "shijiazhuang",
            "Â§™Âéü": "taiyuan",
            "taiyuan": "taiyuan",
            "ÂëºÂíåÊµ©Áâπ": "hohhot",
            "hohhot": "hohhot",
            "Ê≤àÈò≥": "shenyang",
            "shenyang": "shenyang",
            "ÈïøÊò•": "changchun",
            "changchun": "changchun",
            "ÂìàÂ∞îÊª®": "harbin",
            "harbin": "harbin",
            "ÂêàËÇ•": "hefei",
            "hefei": "hefei",
            "ÂçóÊòå": "nanchang",
            "nanchang": "nanchang",
            "ÈÉëÂ∑û": "zhengzhou",
            "zhengzhou": "zhengzhou",
            "ÈïøÊ≤ô": "changsha",
            "changsha": "changsha",
            "ÂçóÂÆÅ": "nanning",
            "nanning": "nanning",
            "Êµ∑Âè£": "haikou",
            "haikou": "haikou",
            "‰∏â‰∫ö": "sanya",
            "sanya": "sanya",
            "Ë¥µÈò≥": "guiyang",
            "guiyang": "guiyang",
            "ÊòÜÊòé": "kunming",
            "kunming": "kunming",
            "ÊãâËê®": "lhasa",
            "lhasa": "lhasa",
            "ÂÖ∞Â∑û": "lanzhou",
            "lanzhou": "lanzhou",
            "Ë•øÂÆÅ": "xining",
            "xining": "xining",
            "Èì∂Â∑ù": "yinchuan",
            "yinchuan": "yinchuan",
            "‰πåÈ≤ÅÊú®ÈΩê": "urumqi",
            "urumqi": "urumqi",
            "ÂØåÂõΩÂ≤õ": "phu_quoc",
            "phu quoc": "phu_quoc",
            "phuquoc": "phu_quoc",
            "Â∑¥ÂéòÂ≤õ": "bali",
            "bali": "bali",
            "Â∑¥Âéò": "bali",
            # ‰∏úÂçó‰∫ö
            "ÊôÆÂêâÂ≤õ": "phuket",
            "phuket": "phuket",
            "ËãèÊ¢ÖÂ≤õ": "koh_samui",
            "koh samui": "koh_samui",
            "Ê∏ÖËøà": "chiang_mai",
            "chiang mai": "chiang_mai",
            "Ê∏ÖËé±": "chiang_rai",
            "chiang rai": "chiang_rai",
            "Áî≤Á±≥": "krabi",
            "krabi": "krabi",
            "ÂçéÊ¨£": "hua_hin",
            "hua hin": "hua_hin",
            "Ëä≠ÊèêÈõÖ": "pattaya",
            "pattaya": "pattaya",
            "È©¨Â∞ºÊãâ": "manila",
            "manila": "manila",
            "ÂÆøÂä°": "cebu",
            "cebu": "cebu",
            "ÈïøÊª©Â≤õ": "boracay",
            "boracay": "boracay",
            "Ê≤≥ÂÜÖ": "hanoi",
            "hanoi": "hanoi",
            "ËÉ°ÂøóÊòéÂ∏Ç": "ho_chi_minh",
            "ho chi minh": "ho_chi_minh",
            "Â≤òÊ∏Ø": "da_nang",
            "da nang": "da_nang",
            "‰ºöÂÆâ": "hoi_an",
            "hoi an": "hoi_an",
            "ËäΩÂ∫Ñ": "nha_trang",
            "nha trang": "nha_trang",
            "Â§ßÂèª": "da_lat",
            "da lat": "da_lat",
            "ÈõÖÂä†Ëææ": "jakarta",
            "jakarta": "jakarta",
            "Êó•ÊÉπ": "yogyakarta",
            "yogyakarta": "yogyakarta",
            "Ê≥óÊ∞¥": "surabaya",
            "surabaya": "surabaya",
            "Ê£âÂÖ∞": "medan",
            "medan": "medan",
            "ÊßüÂüé": "penang",
            "penang": "penang",
            "È©¨ÂÖ≠Áî≤": "malacca",
            "malacca": "malacca",
            "ÂÖ∞Âç°Â®Å": "langkawi",
            "langkawi": "langkawi",
            "Ê≤ôÂ∑¥": "sabah",
            "sabah": "sabah",
            "Ê≤ôÊçûË∂ä": "sarawak",
            "sarawak": "sarawak",
            # ‰∏ú‰∫ö
            "Á¶èÂÜà": "fukuoka",
            "fukuoka": "fukuoka",
            "ÂπøÂ≤õ": "hiroshima",
            "hiroshima": "hiroshima",
            "Êú≠Âπå": "sapporo",
            "sapporo": "sapporo",
            "‰ªôÂè∞": "sendai",
            "sendai": "sendai",
            "Ê®™Êª®": "yokohama",
            "yokohama": "yokohama",
            "Á•ûÊà∑": "kobe",
            "kobe": "kobe",
            "Â•àËâØ": "nara",
            "nara": "nara",
            "ÂÜ≤Áª≥": "okinawa",
            "okinawa": "okinawa",
            "ÈáúÂ±±": "busan",
            "busan": "busan",
            "ÊµéÂ∑ûÂ≤õ": "jeju",
            "jeju": "jeju",
            "Â§ßÈÇ±": "daegu",
            "daegu": "daegu",
            "ÂÖâÂ∑û": "gwangju",
            "gwangju": "gwangju",
            "Â§ßÁî∞": "daejeon",
            "daejeon": "daejeon",
            "‰ªÅÂ∑ù": "incheon",
            "incheon": "incheon",
            # Ê¨ßÊ¥≤
            "ÁΩóÈ©¨": "rome",
            "rome": "rome",
            "Á±≥ÂÖ∞": "milan",
            "milan": "milan",
            "Â®ÅÂ∞ºÊñØ": "venice",
            "venice": "venice",
            "‰ΩõÁΩó‰º¶Ëê®": "florence",
            "florence": "florence",
            "ÈÇ£‰∏çÂãíÊñØ": "naples",
            "naples": "naples",
            "Â∑¥Â°ûÁΩóÈÇ£": "barcelona",
            "barcelona": "barcelona",
            "È©¨Âæ∑Èáå": "madrid",
            "madrid": "madrid",
            "Â°ûÁª¥Âà©‰∫ö": "seville",
            "seville": "seville",
            "ÊüèÊûó": "berlin",
            "berlin": "berlin",
            "ÊÖïÂ∞ºÈªë": "munich",
            "munich": "munich",
            "Ê±âÂ†°": "hamburg",
            "hamburg": "hamburg",
            "ÈòøÂßÜÊñØÁâπ‰∏π": "amsterdam",
            "amsterdam": "amsterdam",
            "ÈπøÁâπ‰∏π": "rotterdam",
            "rotterdam": "rotterdam",
            "Â∏ÉÈ≤ÅÂ°ûÂ∞î": "brussels",
            "brussels": "brussels",
            "Áª¥‰πüÁ∫≥": "vienna",
            "vienna": "vienna",
            "Ëê®Â∞îËå®Â†°": "salzburg",
            "salzburg": "salzburg",
            "ËãèÈªé‰∏ñ": "zurich",
            "zurich": "zurich",
            "Êó•ÂÜÖÁì¶": "geneva",
            "geneva": "geneva",
            "Â∏ÉÊãâÊ†º": "prague",
            "prague": "prague",
            "Â∏ÉËææ‰Ω©ÊñØ": "budapest",
            "budapest": "budapest",
            "ÂçéÊ≤ô": "warsaw",
            "warsaw": "warsaw",
            "ÊñØÂæ∑Âì•Â∞îÊë©": "stockholm",
            "stockholm": "stockholm",
            "Âì•Êú¨ÂìàÊ†π": "copenhagen",
            "copenhagen": "copenhagen",
            "Â••ÊñØÈôÜ": "oslo",
            "oslo": "oslo",
            "Ëµ´Â∞îËæõÂü∫": "helsinki",
            "helsinki": "helsinki",
            "Ëé´ÊñØÁßë": "moscow",
            "moscow": "moscow",
            "Âú£ÂΩºÂæóÂ†°": "st_petersburg",
            "st petersburg": "st_petersburg",
            # ÂåóÁæé
            "Ê¥õÊùâÁü∂": "los_angeles",
            "los angeles": "los_angeles",
            "ÊóßÈáëÂ±±": "san_francisco",
            "san francisco": "san_francisco",
            "ÊãâÊñØÁª¥Âä†ÊñØ": "las_vegas",
            "las vegas": "las_vegas",
            "ËøàÈòøÂØÜ": "miami",
            "miami": "miami",
            "ËäùÂä†Âì•": "chicago",
            "chicago": "chicago",
            "Ê≥¢Â£´È°ø": "boston",
            "boston": "boston",
            "ÂçéÁõõÈ°ø": "washington_dc",
            "washington dc": "washington_dc",
            "Ë•øÈõÖÂõæ": "seattle",
            "seattle": "seattle",
            "Â§ö‰º¶Â§ö": "toronto",
            "toronto": "toronto",
            "Ê∏©Âì•Âçé": "vancouver",
            "vancouver": "vancouver",
            "ËíôÁâπÂà©Â∞î": "montreal",
            "montreal": "montreal",
            # Â§ßÊ¥ãÊ¥≤
            "ÊÇâÂ∞º": "sydney",
            "sydney": "sydney",
            "Â¢®Â∞îÊú¨": "melbourne",
            "melbourne": "melbourne",
            "Â∏ÉÈáåÊñØÁè≠": "brisbane",
            "brisbane": "brisbane",
            "ÁèÄÊñØ": "perth",
            "perth": "perth",
            "ÈòøÂæ∑Ëé±Âæ∑": "adelaide",
            "adelaide": "adelaide",
            "Â••ÂÖãÂÖ∞": "auckland",
            "auckland": "auckland",
            "ÊÉ†ÁÅµÈ°ø": "wellington",
            "wellington": "wellington",
            "Âü∫Áù£Âüé": "christchurch",
            "christchurch": "christchurch",
            # ‰∏≠‰∏ú
            "Ëø™Êãú": "dubai",
            "dubai": "dubai",
            "ÈòøÂ∏ÉÊâéÊØî": "abu_dhabi",
            "abu dhabi": "abu_dhabi",
            "Â§öÂìà": "doha",
            "doha": "doha",
            "ÁßëÂ®ÅÁâπ": "kuwait",
            "kuwait": "kuwait",
            "Âà©ÈõÖÂæó": "riyadh",
            "riyadh": "riyadh",
            "ÂêâËææ": "jeddah",
            "jeddah": "jeddah",
            "‰ºäÊñØÂù¶Â∏ÉÂ∞î": "istanbul",
            "istanbul": "istanbul",
            "ÂÆâÂç°Êãâ": "ankara",
            "ankara": "ankara",
            # ÈùûÊ¥≤
            "ÂºÄÁΩó": "cairo",
            "cairo": "cairo",
            "ÂºÄÊôÆÊï¶": "cape_town",
            "cape town": "cape_town",
            "Á∫¶Áø∞ÂÜÖÊñØÂ†°": "johannesburg",
            "johannesburg": "johannesburg",
            "ÂÜÖÁΩóÊØï": "nairobi",
            "nairobi": "nairobi",
            "ÊãâÂêÑÊñØ": "lagos",
            "lagos": "lagos",
            # ÂçóÁæé
            "Âú£‰øùÁΩó": "sao_paulo",
            "sao paulo": "sao_paulo",
            "ÈáåÁ∫¶ÁÉ≠ÂÜÖÂç¢": "rio_de_janeiro",
            "rio de janeiro": "rio_de_janeiro",
            "Â∏ÉÂÆúËØ∫ÊñØËâæÂà©ÊñØ": "buenos_aires",
            "buenos aires": "buenos_aires",
            "Âà©È©¨": "lima",
            "lima": "lima",
            "Âú£Âú∞‰∫öÂì•": "santiago",
            "santiago": "santiago",
            "Ê≥¢Âì•Â§ß": "bogota",
            "bogota": "bogota",
            "Âä†ÊãâÂä†ÊñØ": "caracas",
            "caracas": "caracas"
        }
        
        for keyword, normalized_name in destination_map.items():
            if keyword in message_lower:
                return normalized_name
        
        return None

    async def _send_influencer_hotel_response(
        self, 
        update: Update, 
        response: str, 
        message_text: str, 
        chat_id: int
    ):
        """Send influencer hotel response with social media data"""
        try:
            # Extract destination from message
            destination = self._extract_destination_from_message(message_text)
            
            if destination:
                # Get Instagram buttons for hotels
                instagram_buttons = await self.llm_service._get_instagram_buttons_for_hotels(response, destination)
                
                if instagram_buttons:
                    # Create Instagram buttons
                    from telegram import InlineKeyboardButton, InlineKeyboardMarkup
                    keyboard = []
                    for button_data in instagram_buttons:
                        keyboard.append([InlineKeyboardButton(
                            button_data["text"], 
                            url=button_data["url"]
                        )])
                    
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    # Send text response with Instagram buttons in one message
                    await update.message.reply_text(
                        response,
                        reply_markup=reply_markup,
                        parse_mode="Markdown"
                    )
                else:
                    # Fallback to regular response
                    await update.message.reply_text(response, parse_mode="Markdown")
            else:
                # Fallback to regular response
                await update.message.reply_text(response, parse_mode="Markdown")
                
        except Exception as e:
            logger.error(f"Error sending influencer hotel response: {e}")
            # Fallback to regular response
            await update.message.reply_text(response, parse_mode="Markdown")

    def _is_bot_mentioned(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
        """
        Check if the bot is mentioned in the message
        
        Args:
            update: Telegram update object
            context: Bot context
            
        Returns:
            bool: True if bot is mentioned, False otherwise
        """
        try:
            message = update.message
            if not message:
                return False
            
            # Check for @mentions in the message text
            if message.text:
                # Get bot username
                bot_username = context.bot.username
                if bot_username:
                    # Check for @bot_username in the message
                    if f"@{bot_username}" in message.text:
                        return True
                
                # Check for @all or @everyone (common group mentions)
                if "@all" in message.text.lower() or "@everyone" in message.text.lower():
                    return True
            
            # Check for entities (mentions, hashtags, etc.)
            if message.entities:
                for entity in message.entities:
                    if entity.type == "mention":
                        # Extract the mentioned username
                        mentioned_username = message.text[entity.offset:entity.offset + entity.length]
                        if mentioned_username == f"@{context.bot.username}":
                            return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking bot mention: {e}")
            return False